PayProp API Comprehensive Integration Guide
Authentication & Base Configuration

Base URL: https://uk.payprop.com/api/agency/v1.1
Authentication: API Key in Authorization header
Authorization: APIkey MTYzMTg2MDY3MS1wWikuVzsjKnlGJFFKb0RYWCwhe1sjdUBGZ0Y3RT9QPw==

Rate Limit: 5 requests per second maximum
Content-Type: application/json
All connections: HTTPS required

Sync Status Terminology

payPropId: Unique PayProp identifier (^[a-zA-Z0-9]+$, 10-32 chars)
customerId: Your internal reference ID (^[a-zA-Z0-9_-]+$, max 50 chars)
customerReference: Human-readable reference visible in PayProp UI
Ready for Sync: All required fields populated, validation passes
Synced: Entity has payPropId assigned and exists in PayProp
Modified: Use modified_from_time to track changes


Core Entity Management
Properties
Create Property
Endpoint: POST /entity/property
Minimum Required Fields:
json{
  "name": "Property address line 1",  // Required, unique, max 255 chars
  "customer_id": "internal_ref_123",   // Optional but recommended
  "customer_reference": "PROP001"      // Optional, visible in PayProp
}
Complete Property Schema:
json{
  "name": "123 Main Street",
  "customer_id": "prop_123",
  "customer_reference": "PROP001",
  "agent_name": "Central London Team",           // For portfolio subdivision
  "responsible_agent_id": "agent_payprop_id",   // Portfolio manager assignment
  "notes": "Property specific notes",
  "address": {
    "address_line_1": "123 Main Street",
    "address_line_2": "Apt 4B",
    "city": "London",
    "state": "England", 
    "postal_code": "SW1A 1AA",
    "country_code": "UK",
    "latitude": "51.5074",
    "longitude": "-0.1278"
  },
  "settings": {
    "monthly_payment": 1500.00,        // Expected rent amount
    "listing_from": "2024-01-01",      // Listing start date
    "listing_to": "2024-12-31",        // Optional listing end
    "enable_payments": true,           // Allow outgoing payments
    "hold_owner_funds": false,         // Divert to property account
    "minimum_balance": 0.00,           // Min property account balance
    "verify_payments": true            // Require payment approval
  }
}
Other Property Endpoints:

GET /entity/property/{id} - Retrieve property
PUT /entity/property/{id} - Update property
GET /export/properties - List/search properties with advanced filtering

Tenants
Create Tenant
Endpoint: POST /entity/tenant
Individual Tenant (Required Fields):
json{
  "account_type": "individual",
  "first_name": "John",              // 2-50 chars, required for individual
  "last_name": "Smith",              // 2-50 chars, required for individual
  "email_address": "john@email.com", // Required, max 50 chars
  "mobile_number": "447712345678",   // Optional, pattern: ^[1-9]\d+$
  "customer_id": "tenant_456",       // Your internal reference
  "customer_reference": "TEN001"     // Visible in PayProp
}
Business Tenant (Required Fields):
json{
  "account_type": "business",
  "business_name": "Company Ltd",    // 2-50 chars, required for business
  "email_address": "company@email.com",
  "customer_id": "tenant_business_789"
}
Complete Tenant Schema:
json{
  "account_type": "individual",      // "individual" or "business"
  "first_name": "John",
  "last_name": "Smith", 
  "business_name": "Company Ltd",    // Required if account_type = "business"
  "email_address": "tenant@email.com",
  "email_cc": ["guarantor@email.com"], // Up to 10 email addresses
  "mobile_number": "447712345678",
  "phone": "442071234567",
  "date_of_birth": "1990-05-15",
  "id_number": "AB123456C",          // Passport/license number
  "id_type_id": "payprop_id_type",   // From /id-types endpoint
  "vat_number": "GB123456789",
  "lead_days": 0,                    // Days to send invoices in advance (0-31)
  "notify_email": true,
  "notify_sms": true,
  "comment": "Additional notes about tenant",
  "customer_id": "tenant_123",
  "customer_reference": "TEN001",
  "address": {
    "address_line_1": "123 Rental Street",
    "address_line_2": "Flat 2",
    "city": "London",
    "postal_code": "SW1A 1AA",
    "country_code": "UK"
  },
  "bank_account": {                  // Optional, for record keeping only
    "account_name": "John Smith",
    "account_number": "12345678",    // 3-8 digits
    "branch_code": "123456",         // 6 digits
    "bank_name": "Bank Name",
    "branch_name": "Branch Name"
  },
  "has_bank_account": true           // Required if providing bank_account
}
Other Tenant Endpoints:

GET /entity/tenant/{id} - Retrieve tenant
PUT /entity/tenant/{id} - Update tenant
GET /export/tenants - List/search tenants

Beneficiaries (Property Owners)
Create Beneficiary
Endpoint: POST /entity/beneficiary
Individual Owner (Required Fields):
json{
  "account_type": "individual",
  "payment_method": "local",         // "local", "international", or "cheque"
  "first_name": "Owner",
  "last_name": "Name",
  "email_address": "owner@email.com"
}
Business Owner (Required Fields):
json{
  "account_type": "business",
  "payment_method": "local", 
  "business_name": "Property Company Ltd",
  "email_address": "business@email.com"
}
Complete Beneficiary Schema:
json{
  "account_type": "individual",      // "individual" or "business"
  "payment_method": "local",         // "local", "international", "cheque"
  "first_name": "Property",
  "last_name": "Owner",
  "business_name": "Property Co Ltd", // Required if account_type = "business"
  "email_address": "owner@email.com",
  "email_cc": ["accountant@email.com"], // Up to 10 addresses
  "mobile": "447712345678",          // Pattern: ^[1-9]\d+$
  "phone": "442071234567",
  "fax": "442071234568",
  "id_number": "AB123456C",
  "id_type_id": "payprop_id_type",
  "vat_number": "GB123456789",
  "customer_id": "owner_123",
  "customer_reference": "OWN001",
  "comment": "Notes about the property owner",
  "address": {                       // Required for international/cheque
    "address_line_1": "123 Owner Street",
    "city": "London",
    "state": "England",              // Required for international
    "postal_code": "SW1A 1AA",       // Required for international
    "country_code": "UK"
  },
  "bank_account": {
    "account_name": "Property Owner",
    "account_number": "12345678",    // For local: 3-8 digits, pattern: ^\d+$
    "branch_code": "123456",         // For local: 6 digits, required
    "bank_name": "Bank Name",
    "branch_name": "Branch Name",
    "iban": "GB29NWBK60161331926819", // For international (either IBAN or account_number)
    "swift_code": "NWBKGB2L",       // For international, required
    "country_code": "UK"             // For international, required
  },
  "communication_preferences": {
    "email": {
      "enabled": true,
      "payment_advice": true
    }
  }
}
Payment Method Requirements:

local: Requires account_number, branch_code, account_name
international: Requires full address, swift_code, country_code, and either iban or account_number
cheque: Requires full address

Other Beneficiary Endpoints:

GET /entity/beneficiary/{id} - Retrieve beneficiary
PUT /entity/beneficiary/{id} - Update beneficiary
GET /export/beneficiaries - List/search beneficiaries


Financial Management
Invoices & Payments
Create Invoice
Endpoint: POST /entity/invoice
json{
  "tenant_id": "tenant_payprop_id",
  "property_id": "property_payprop_id", 
  "amount": 1500.00,                // Required, minimum 0.01
  "category_id": "category_payprop_id", // From /invoices/categories
  "frequency": "M",                  // O,W,2W,4W,M,2M,Q,6M,A
  "start_date": "2024-01-01",
  "end_date": "2024-12-31",         // Optional
  "payment_day": 1,                 // 1-31, day of month for recurring
  "description": "Monthly rent",
  "has_tax": true,
  "tax_amount": 300.00,
  "is_direct_debit": false,
  "has_invoice_period": true,       // For recurring invoices
  "customer_id": "invoice_123"
}
Adhoc Invoice (One-time):
json{
  "tenant_id": "tenant_payprop_id",
  "property_id": "property_payprop_id",
  "amount": 250.00,
  "category_id": "category_payprop_id",
  "frequency": "O",                 // "O" = One-time
  "description": "Cleaning fee",
  "customer_id": "adhoc_invoice_456"
}
Create Payment
Endpoint: POST /entity/payment
json{
  "property_id": "property_payprop_id",
  "beneficiary_type": "beneficiary", // "agency", "beneficiary", "global_beneficiary", "property_account", "deposit_account"
  "beneficiary_id": "beneficiary_payprop_id", // Required if beneficiary_type = "beneficiary"
  "frequency": "M",                  // O,W,2W,4W,M,2M,Q,6M,A
  "amount": 1200.00,                // Optional if using percentage
  "percentage": 80.00,              // 0.01-100, optional if using amount
  "category_id": "category_payprop_id",
  "reference": "Monthly owner payment", // Required if beneficiary_type = "beneficiary"
  "start_date": "2024-01-01",
  "end_date": "2024-12-31",         // Optional
  "payment_day": 5,                 // 0-31, day of month
  "description": "Owner rent payment",
  "enabled": true,
  "use_money_from": "tenant",       // "any_tenant", "tenant", "property_account"
  "tenant_id": "tenant_payprop_id", // Optional, for specific tenant
  "has_tax": false,
  "maintenance_ticket_id": "ticket_payprop_id", // Optional, link to maintenance
  "no_commission_amount": 100.00,   // Amount exempt from commission
  "customer_id": "payment_789"
}
Financial Transactions
Credit Notes (Reduce Tenant Balance)
Endpoint: POST /transactions/credit-note
json{
  "tenant_id": "tenant_payprop_id",
  "property_id": "property_payprop_id", 
  "amount": 150.00,
  "category_id": "category_payprop_id",
  "description": "Damage deposit refund",
  "has_tax": false,
  "reference": "REF001"
}
Debit Notes (Increase Tenant Balance)
Endpoint: POST /transactions/debit-note
json{
  "tenant_id": "tenant_payprop_id",
  "property_id": "property_payprop_id",
  "amount": 200.00,
  "category_id": "category_payprop_id", 
  "description": "Late payment fee",
  "has_tax": true,
  "tax_amount": 40.00,
  "reference": "LATE001"
}
Posted Payments (Expected Payments)
Endpoint: POST /posted-payments
json{
  "tenant_id": "tenant_payprop_id",
  "property_id": "property_payprop_id",
  "amount": 1500.00,
  "date": "2024-01-01",
  "reference": "Expected rent payment",
  "type_id": "type_from_posted_payments_types_endpoint"
}
Secondary Payments (Split Payments)
Endpoint: POST /entity/secondary-payment
json{
  "primary_payment_id": "payment_payprop_id",
  "beneficiary_id": "secondary_beneficiary_id",
  "amount": 300.00,
  "percentage": 20.00,              // Alternative to amount
  "reference": "Co-owner payment",
  "description": "Secondary owner split"
}

Portfolio Organization & Management
Tags System (Critical for Portfolios)
Create Tag
Endpoint: POST /tags
json{
  "name": "Central London Portfolio"  // Max 32 chars, alphanumeric + spaces/hyphens/underscores
}
Link Tags to Properties
Endpoint: POST /tags/entities/property/{property_id}
json{
  "tags": [
    "Central London Portfolio",       // Can use tag names
    "tag_payprop_id_123",            // Or tag external IDs
    "High Value Properties"
  ]
}
Get Properties by Tag
Endpoint: GET /tags/{tag_external_id}/entities?entity_type=property
Search Tags
Endpoint: GET /tags
Query Parameters:

name - Filter by tag name
entity_type - Properties/tenants/beneficiaries with this tag
entity_id - Tags linked to specific entity

Unlink Tag from Entity
Endpoint: DELETE /tags/{tag_external_id}/entities?entity_type=property&entity_id={property_id}
Property Organization Fields
json{
  "agent_name": "Portfolio Team Alpha",    // Subdivision field for portfolio grouping
  "responsible_agent_id": "agent_id",     // Assign portfolio manager
  "customer_reference": "PORTFOLIO_A_001" // Your portfolio reference system
}

Maintenance Management
Maintenance Tickets
Create Maintenance Ticket
Endpoint: POST /maintenance/tickets
json{
  "property_id": "property_payprop_id",
  "tenant_id": "tenant_payprop_id",    // Optional
  "category_id": "category_payprop_id", // From /maintenance/categories
  "title": "Leaking tap in kitchen",
  "description": "Tenant reports dripping tap",
  "status_id": "new",                  // "new", "in_progress", "on_hold", "rejected", "resolved"
  "is_emergency": false,
  "estimated_cost": 150.00,
  "notes": "Internal notes about ticket"
}
Update Maintenance Ticket
Endpoint: PUT /maintenance/tickets/{ticket_id}
json{
  "status_id": "in_progress",
  "notes": "Plumber scheduled for tomorrow",
  "estimated_cost": 200.00
}
Get Maintenance Tickets
Endpoint: GET /maintenance/tickets
Query Parameters:

property_id - Filter by property
tenant_id - Filter by tenant
category_id - Filter by category
status_id - Filter by status
is_emergency - Filter emergency tickets
from_date / to_date - Date range

Maintenance Messages
Add Message to Ticket
Endpoint: POST /maintenance/tickets/{ticket_id}/messages
json{
  "message": "Plumber has been contacted and will arrive at 2pm",
  "author_type": "agency",             // "agency" or "tenant"
  "is_private": false                  // Internal message if true
}
Get Ticket Messages
Endpoint: GET /maintenance/tickets/{ticket_id}/messages
File Attachments
Upload File to Maintenance Ticket
Endpoint: POST /attachments/maintenance-ticket/{ticket_id}
Content-Type: multipart/form-data
attachment: [FILE_DATA]
Get Attachments
Endpoint: GET /attachments/maintenance-ticket/{ticket_id}
Download Attachment
Endpoint: GET /attachments/{attachment_id}

Real-time Notifications (Webhooks)
Configure Webhooks
Endpoint: PUT /webhooks
json{
  "url": "https://yourapp.com/webhooks/payprop",
  "secret_key": "your_webhook_secret_for_signing", // Optional but recommended
  "events": [
    "payment.create",
    "payment.update", 
    "invoice.create",
    "maintenance_ticket.create",
    "maintenance_ticket.update",
    "property_account_balance.update",
    "beneficiary.update",
    "tenant.update",
    "property.update",
    "credit_note.create",
    "debit_note.create",
    "secondary_payment.create"
  ]
}
Webhook Event Structure
json{
  "agency": {
    "id": "agency_payprop_id",
    "name": "Your Agency Name"
  },
  "events": [
    {
      "action": "create",              // "create", "update", "delete", "restore"
      "type": "payment",               // Entity type that changed
      "data": {
        "id": "payment_payprop_id",
        "amount": "1500.00",
        "status": "new",
        "date": "2024-01-15",
        "property_id": "property_payprop_id",
        "tenant_id": "tenant_payprop_id"
      }
    }
  ]
}
Webhook Verification
If you provide a secret_key, PayProp includes signature headers:

X-PayProp-Webhook-Signature - HMAC SHA256 signature
X-PayProp-Webhook-Timestamp - Timestamp for replay protection

Verification process:

Concatenate: timestamp.webhook_payload
Compute HMAC-SHA256 with your secret key
Compare with signature header

Get Webhook Failures
Endpoint: GET /webhooks/failures
Query Parameters:

from_date / to_date - Date range for failures
rows / page - Pagination


Reminders & Task Management
Entity Reminders
Create Reminder
Endpoint: POST /reminders/{entity_type}/{entity_id}
Entity types: tenant, property, beneficiary
json{
  "title": "Property inspection due",
  "description": "Annual property inspection required",
  "reminder_date": "2024-06-01",
  "priority": "high",               // "low", "medium", "high"
  "status": "active"                // "active", "complete"
}
Update Reminder
Endpoint: PUT /reminders/{entity_type}/{entity_id}/{reminder_id}
Get Reminders
Endpoint: GET /reminders/{entity_type}/{entity_id}
Query Parameters:

statuses - Filter by status (comma-separated)
reminder_id - Specific reminder


Comprehensive Reporting
Portfolio-Level Reports
Agency Income Report
Endpoint: GET /report/agency/income
Query Parameters:

year + month - Monthly summary
on_date - Detailed report for specific date

json{
  "period": "2024-01",
  "total_income": 45000.00,
  "total_commission": 4500.00,
  "property_count": 30,
  "active_tenants": 28,
  "arrears_amount": 1200.00,
  "by_agent": [
    {
      "agent_name": "Central Team",
      "income": 20000.00,
      "commission": 2000.00,
      "property_count": 15
    }
  ]
}
Processing Summary
Endpoint: GET /report/processing-summary
Query Parameters:

from_date / to_date - Date range (defaults to today)

json{
  "period": {
    "from": "2024-01-01",
    "to": "2024-01-31"
  },
  "incoming_payments": {
    "count": 150,
    "total_amount": 75000.00,
    "reconciled_count": 148,
    "unreconciled_count": 2
  },
  "outgoing_payments": {
    "count": 95,
    "total_amount": 60000.00,
    "pending_count": 5,
    "processed_count": 90
  },
  "maintenance_tickets": {
    "created": 12,
    "resolved": 8,
    "average_resolution_days": 3.5
  }
}
Beneficiary Balances
Endpoint: GET /report/beneficiary/balances
Query Parameters:

property_id - Filter by property
beneficiary_id - Specific beneficiary
beneficiary_type - Type filter
balance_above / balance_below - Amount filters

Tenant Balances
Endpoint: GET /report/tenant/balances
Query Parameters:

property_id - Filter by property
tenant_id - Specific tenant
balance_above / balance_below - Amount filters
on_date - Balance as of date

All Payments Report
Endpoint: GET /report/all-payments
Query Parameters:

tenant_id, property_id, category_id - Entity filters
from_date / to_date - Date range
filter_by - reconciliation_date or remittance_date
payment_batch_id - Specific batch
maintenance_ticket_id - Maintenance-related payments

ICDN Report (Invoices/Credit/Debit Notes)
Endpoint: GET /report/icdn
Query Parameters:

tenant_id, property_id, category_id - Filters
type - invoice, debit_note, credit_note
from_date / to_date - Date range

Tenant Statement
Endpoint: GET /report/tenant/statement
Query Parameters:

property_id - Required
tenant_id - Required
from_date / to_date - Date range


Advanced Search & Export
Properties Export
Endpoint: GET /export/properties
Advanced Query Parameters:
?rows=50
&page=1
&modified_from_time=2024-01-01T00:00:00
&modified_from_timezone=Europe/London
&external_id=property_payprop_id
&customer_reference=PROP001
&customer_id=internal_prop_123
&search_by=name,city,postal_code
&search_value=London
&include_last_processing_info=true
&include_active_tenancies=true
&include_commission=true
&include_balance=true
&include_contract_amount=true
&is_archived=false
Tenants Export
Endpoint: GET /export/tenants
?property_id=property_payprop_id
&search_by=first_name,last_name,email_address
&search_value=John
&customer_id=internal_tenant_123
&is_archived=false
Beneficiaries Export
Endpoint: GET /export/beneficiaries
?owners=true
&search_by=first_name,last_name,business_name
&search_value=Property
&bank_account_number=12345678
&bank_branch_code=123456

Categories & Reference Data
Transaction Categories
Invoice Categories

GET /invoices/categories - List categories
POST /invoices/categories - Create category
PUT /invoices/categories/{id} - Update category

Payment Categories

GET /payments/categories - List categories
POST /payments/categories - Create category
PUT /payments/categories/{id} - Update category

Reference Data

GET /transactions/frequencies - Available frequencies (O,W,2W,4W,M,2M,Q,6M,A)
GET /transactions/tax - Tax information
GET /id-types - Available ID types
GET /global-beneficiaries - Global beneficiary list
GET /agents - Agency agents
GET /maintenance/categories - Maintenance categories
GET /posted-payments/types - Posted payment types

Account Information

GET /meta/me - Token/account information


Document Generation
PDF Reports
Agency Invoice
Endpoint: GET /documents/pdf/agency-invoice
Query Parameters:

year - Required (e.g., 2024)
month - Required (1-12)

Owner Statement
Endpoint: GET /documents/pdf/owner-statement
Query Parameters:

property_id - Required
beneficiary_id - Required
from_date / to_date - Optional date range


Error Handling & Best Practices
HTTP Response Codes

200 - Success
400 - Bad Request (validation errors)
401 - Unauthorized (invalid API key)
403 - Forbidden (insufficient permissions)
404 - Not Found
409 - Conflict (duplicate data)
413 - File too large (attachments)
415 - Invalid file type (attachments)
429 - Too many requests (rate limit)
500 - Internal server error
501 - Not implemented
503 - Service unavailable

Error Response Format
json{
  "errors": [
    {
      "message": "Could not find entity based on given customer ID"
    }
  ],
  "status": 404
}
Rate Limiting

Maximum 5 requests per second
Exceeding limit triggers 30-second penalty
Plan API calls accordingly for bulk operations

API Versioning

Current version: v1.1
PayProp may add new JSON fields without version increment
Always handle unknown fields gracefully
Legacy versions remain available but unsupported

Pagination
All list endpoints support pagination:
?rows=25&page=1
Response includes Link header with navigation URLs and pagination object:
json{
  "items": [...],
  "pagination": {
    "page": 1,
    "rows": 25,
    "total_rows": 100,
    "total_pages": 4
  }
}

Implementation Architecture
Sync Service Implementation
javapublic class PayPropSyncService {
    
    // Property sync with portfolio context
    public String syncPropertyToPayProp(Long propertyId) {
        Property property = validatePropertyReadyForSync(propertyId);
        PropertyDTO dto = buildPropertyDTO(property);
        
        // Add portfolio context
        dto.setAgentName(property.getPortfolio().getTeamName());
        dto.setCustomerReference(property.getPortfolio().getPrefix() + property.getReference());
        
        PayPropResponse response = payPropClient.createProperty(dto);
        property.setPayPropId(response.getId());
        
        // Link to portfolio tags
        linkPropertyToPortfolioTags(response.getId(), property.getPortfolio());
        
        return response.getId();
    }
    
    // Maintenance ticket integration
    public void syncMaintenanceTicket(MaintenanceRequest request) {
        MaintenanceTicketDTO dto = MaintenanceTicketDTO.builder()
            .propertyId(request.getProperty().getPayPropId())
            .tenantId(request.getTenant().getPayPropId())
            .title(request.getTitle())
            .description(request.getDescription())
            .categoryId(request.getCategory().getPayPropId())
            .isEmergency(request.isUrgent())
            .build();
            
        PayPropResponse response = payPropClient.createMaintenanceTicket(dto);
        request.setPayPropTicketId(response.getId());
        
        // Link any related payments
        if (request.getEstimatedCost() != null) {
            createMaintenancePayment(response.getId(), request);
        }
    }
}
Webhook Handler Implementation
java@RestController
public class PayPropWebhookController {
    
    @PostMapping("/webhooks/payprop")
    public ResponseEntity<Void> handleWebhook(
            @RequestBody PayPropWebhookEvent event,
            @RequestHeader("X-PayProp-Webhook-Signature") String signature,
            @RequestHeader("X-PayProp-Webhook-Timestamp") String timestamp) {
        
        // Verify webhook authenticity
        if (!webhookVerifier.verifySignature(event, signature, timestamp)) {
            return ResponseEntity.status(401).build();
        }
        
        // Process events
        for (PayPropEvent payPropEvent : event.getEvents()) {
            switch (payPropEvent.getType()) {
                case "payment":
                    handlePaymentEvent(payPropEvent);
                    break;
                case "maintenance_ticket":
                    handleMaintenanceEvent(payPropEvent);
                    break;
                case "property_account_balance":
                    updatePortfolioBalance(payPropEvent);
                    break;
                case "tenant":
                    handleTenantEvent(payPropEvent);
                    break;
                case "beneficiary":
                    handleBeneficiaryEvent(payPropEvent);
                    break;
            }
        }
        
        return ResponseEntity.ok().build();
    }
    
    private void handlePaymentEvent(PayPropEvent event) {
        // Update local payment status and portfolio analytics
        paymentService.updateFromWebhook(event.getData());
        portfolioAnalyticsService.recalculateMetrics(event.getData().getPropertyId());
    }
    
    private void handleMaintenanceEvent(PayPropEvent event) {
        // Sync maintenance ticket status
        maintenanceService.updateTicketStatus(event.getData().getId(), event.getData().getStatus());
        
        // Update portfolio maintenance metrics
        portfolioService.updateMaintenanceStats(event.getData().getPropertyId());
    }
}
Portfolio Analytics Service
java@Service
public class PortfolioAnalyticsService {
    
    public PortfolioDashboard buildComprehensiveDashboard(Long portfolioId) {
        Portfolio portfolio = portfolioRepository.findById(portfolioId);
        List<Property> properties = getPortfolioProperties(portfolioId);
        
        // Get PayProp reports
        AgencyIncomeReport income = payPropClient.getAgencyIncomeReport(
            LocalDate.now().getYear(), 
            LocalDate.now().getMonthValue()
        );
        
        ProcessingSummaryReport processing = payPropClient.getProcessingSummary(
            LocalDate.now().minusMonths(1),
            LocalDate.now()
        );
        
        // Aggregate portfolio-specific data
        PortfolioMetrics metrics = calculatePortfolioMetrics(properties, income, processing);
        
        return PortfolioDashboard.builder()
            .portfolio(portfolio)
            .totalProperties(properties.size())
            .totalRentPotential(metrics.getTotalRent())
            .actualIncome(metrics.getActualIncome())
            .occupancyRate(metrics.getOccupancyRate())
            .maintenanceTickets(getMaintenanceStats(properties))
            .paymentPerformance(metrics.getPaymentStats())
            .balanceSummary(metrics.getBalanceSummary())
            .recentActivity(getRecentActivity(properties))
            .build();
    }
    
    private MaintenanceStats getMaintenanceStats(List<Property> properties) {
        List<String> propertyIds = properties.stream()
            .map(Property::getPayPropId)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
            
        int totalTickets = 0;
        int openTickets = 0;
        BigDecimal totalCost = BigDecimal.ZERO;
        
        for (String propertyId : propertyIds) {
            List<MaintenanceTicket> tickets = payPropClient.getMaintenanceTickets(
                propertyId, LocalDate.now().minusMonths(3), LocalDate.now()
            );
            
            totalTickets += tickets.size();
            openTickets += tickets.stream()
                .mapToInt(t -> t.getStatus().equals("resolved") ? 0 : 1)
                .sum();
                
            totalCost = totalCost.add(
                tickets.stream()
                    .map(MaintenanceTicket::getEstimatedCost)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO, BigDecimal::add)
            );
        }
        
        return MaintenanceStats.builder()
            .totalTickets(totalTickets)
            .openTickets(openTickets)
            .totalCost(totalCost)
            .averageCostPerTicket(totalTickets > 0 ? totalCost.divide(BigDecimal.valueOf(totalTickets), 2, RoundingMode.HALF_UP) : BigDecimal.ZERO)
            .build();
    }
}

Database Schema Extensions
Portfolio Management Tables
sql-- Enhanced property table
ALTER TABLE properties ADD COLUMN payprop_id VARCHAR(32);
ALTER TABLE properties ADD COLUMN customer_reference VARCHAR(50);
ALTER TABLE properties ADD COLUMN responsible_agent_payprop_id VARCHAR(32);
ALTER TABLE properties ADD COLUMN agent_name VARCHAR(50);
ALTER TABLE properties ADD COLUMN sync_status ENUM('NOT_READY', 'READY', 'SYNCED', 'ERROR') DEFAULT 'NOT_READY';
ALTER TABLE properties ADD COLUMN last_synced_at TIMESTAMP NULL;

-- Portfolio tags mapping
CREATE TABLE portfolio_tags (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    portfolio_id BIGINT NOT NULL,
    tag_name VARCHAR(100) NOT NULL,
    payprop_tag_id VARCHAR(32),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(id),
    UNIQUE KEY unique_portfolio_tag (portfolio_id, tag_name)
);

-- Maintenance tickets
CREATE TABLE maintenance_tickets (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    property_id BIGINT NOT NULL,
    tenant_id BIGINT,
    payprop_ticket_id VARCHAR(32),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    status ENUM('NEW', 'IN_PROGRESS', 'ON_HOLD', 'REJECTED', 'RESOLVED') DEFAULT 'NEW',
    is_emergency BOOLEAN DEFAULT FALSE,
    estimated_cost DECIMAL(10,2),
    actual_cost DECIMAL(10,2),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_date TIMESTAMP NULL,
    FOREIGN KEY (property_id) REFERENCES properties(id),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_property_status (property_id, status),
    INDEX idx_payprop_ticket (payprop_ticket_id)
);

-- Financial adjustments tracking
CREATE TABLE financial_adjustments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    property_id BIGINT NOT NULL,
    tenant_id BIGINT,
    payprop_transaction_id VARCHAR(32),
    type ENUM('CREDIT_NOTE', 'DEBIT_NOTE') NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    reason VARCHAR(255),
    reference VARCHAR(100),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (property_id) REFERENCES properties(id),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_property_type (property_id, type)
);

-- Webhook events log
CREATE TABLE webhook_events (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_type VARCHAR(50) NOT NULL,
    event_action VARCHAR(20) NOT NULL,
    payprop_entity_id VARCHAR(32),
    payload JSON,
    processed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processing_status ENUM('PENDING', 'PROCESSED', 'FAILED') DEFAULT 'PENDING',
    error_message TEXT,
    INDEX idx_entity_type (payprop_entity_id, event_type),
    INDEX idx_status (processing_status)
);

-- Portfolio reminders
CREATE TABLE portfolio_reminders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    portfolio_id BIGINT,
    property_id BIGINT,
    tenant_id BIGINT,
    beneficiary_id BIGINT,
    payprop_reminder_id VARCHAR(32),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    reminder_date DATE NOT NULL,
    priority ENUM('LOW', 'MEDIUM', 'HIGH') DEFAULT 'MEDIUM',
    status ENUM('ACTIVE', 'COMPLETE', 'CANCELLED') DEFAULT 'ACTIVE',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP NULL,
    FOREIGN KEY (portfolio_id) REFERENCES portfolios(id),
    FOREIGN KEY (property_id) REFERENCES properties(id),
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    INDEX idx_portfolio_status (portfolio_id, status),
    INDEX idx_reminder_date (reminder_date, status)
);

-- PayProp sync status tracking
CREATE TABLE payprop_sync_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    entity_type ENUM('PROPERTY', 'TENANT', 'BENEFICIARY', 'INVOICE', 'PAYMENT') NOT NULL,
    entity_id BIGINT NOT NULL,
    payprop_id VARCHAR(32),
    sync_action ENUM('CREATE', 'UPDATE', 'DELETE') NOT NULL,
    sync_status ENUM('SUCCESS', 'FAILED', 'PENDING') NOT NULL,
    request_payload JSON,
    response_payload JSON,
    error_message TEXT,
    synced_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_entity (entity_type, entity_id),
    INDEX idx_payprop_id (payprop_id),
    INDEX idx_sync_status (sync_status)
);

Frontend Integration Examples
Portfolio Dashboard Controller
java@Controller
@RequestMapping("/portfolio")
public class PortfolioDashboardController {
    
    @GetMapping("/{portfolioId}/dashboard")
    public String portfolioDashboard(@PathVariable Long portfolioId, Model model) {
        Portfolio portfolio = portfolioService.findById(portfolioId);
        
        // Build comprehensive dashboard
        PortfolioDashboard dashboard = portfolioAnalyticsService.buildComprehensiveDashboard(portfolioId);
        
        // Portfolio metrics
        model.addAttribute("portfolio", portfolio);
        model.addAttribute("totalProperties", dashboard.getTotalProperties());
        model.addAttribute("occupiedCount", dashboard.getOccupiedCount());
        model.addAttribute("vacantCount", dashboard.getVacantCount());
        model.addAttribute("totalRentPotential", dashboard.getTotalRentPotential());
        model.addAttribute("actualIncome", dashboard.getActualIncome());
        model.addAttribute("occupancyRate", dashboard.getOccupancyRate());
        
        // Sync status
        model.addAttribute("syncedProperties", dashboard.getSyncedProperties());
        model.addAttribute("unsyncedProperties", dashboard.getUnsyncedProperties());
        model.addAttribute("syncErrors", dashboard.getSyncErrors());
        
        // Financial overview
        model.addAttribute("totalBalance", dashboard.getTotalBalance());
        model.addAttribute("arrearsAmount", dashboard.getArrearsAmount());
        model.addAttribute("monthlyIncome", dashboard.getMonthlyIncome());
        model.addAttribute("monthlyExpenses", dashboard.getMonthlyExpenses());
        
        // Maintenance overview
        MaintenanceStats maintenance = dashboard.getMaintenanceStats();
        model.addAttribute("totalMaintenanceTickets", maintenance.getTotalTickets());
        model.addAttribute("openMaintenanceTickets", maintenance.getOpenTickets());
        model.addAttribute("maintenanceCosts", maintenance.getTotalCost());
        model.addAttribute("averageMaintenanceCost", maintenance.getAverageCostPerTicket());
        
        // Recent activity
        model.addAttribute("recentPayments", dashboard.getRecentPayments());
        model.addAttribute("recentMaintenanceTickets", dashboard.getRecentMaintenance());
        model.addAttribute("upcomingReminders", dashboard.getUpcomingReminders());
        
        return "portfolio/dashboard";
    }
    
    @GetMapping("/{portfolioId}/properties")
    public String portfolioProperties(@PathVariable Long portfolioId, Model model,
            @RequestParam(defaultValue = "ALL") String syncStatus,
            @RequestParam(defaultValue = "ALL") String occupancyStatus) {
        
        Portfolio portfolio = portfolioService.findById(portfolioId);
        List<Property> properties = propertyService.findByPortfolioWithFilters(
            portfolioId, syncStatus, occupancyStatus
        );
        
        // Add sync status counts
        Map<String, Long> syncStatusCounts = properties.stream()
            .collect(Collectors.groupingBy(
                p -> p.getPayPropId() != null ? "SYNCED" : "UNSYNCED",
                Collectors.counting()
            ));
        
        model.addAttribute("portfolio", portfolio);
        model.addAttribute("properties", properties);
        model.addAttribute("syncStatusCounts", syncStatusCounts);
        model.addAttribute("currentSyncFilter", syncStatus);
        model.addAttribute("currentOccupancyFilter", occupancyStatus);
        
        return "portfolio/properties";
    }
    
    @PostMapping("/{portfolioId}/sync-all")
    @ResponseBody
    public ResponseEntity<SyncResult> syncAllProperties(@PathVariable Long portfolioId) {
        try {
            SyncResult result = portfolioSyncService.syncAllPropertiesInPortfolio(portfolioId);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body(SyncResult.error("Failed to sync portfolio: " + e.getMessage()));
        }
    }
    
    @GetMapping("/{portfolioId}/maintenance")
    public String portfolioMaintenance(@PathVariable Long portfolioId, Model model,
            @RequestParam(defaultValue = "ALL") String status,
            @RequestParam(required = false) String propertyId) {
        
        Portfolio portfolio = portfolioService.findById(portfolioId);
        
        // Get maintenance tickets for portfolio
        List<MaintenanceTicket> tickets = maintenanceService.findByPortfolioWithFilters(
            portfolioId, status, propertyId
        );
        
        // Get summary stats
        MaintenanceStats stats = maintenanceService.calculateStatsForPortfolio(portfolioId);
        
        model.addAttribute("portfolio", portfolio);
        model.addAttribute("maintenanceTickets", tickets);
        model.addAttribute("maintenanceStats", stats);
        model.addAttribute("currentStatusFilter", status);
        model.addAttribute("currentPropertyFilter", propertyId);
        
        return "portfolio/maintenance";
    }
}
Real-time Updates with WebSockets
java@Component
public class PortfolioWebSocketHandler {
    
    @EventListener
    public void handlePayPropWebhook(PayPropWebhookEvent event) {
        // Process webhook and notify connected clients
        for (PayPropEvent payPropEvent : event.getEvents()) {
            if ("payment".equals(payPropEvent.getType())) {
                // Find affected portfolios
                String propertyId = payPropEvent.getData().getPropertyId();
                List<Portfolio> affectedPortfolios = portfolioService.findByPropertyPayPropId(propertyId);
                
                for (Portfolio portfolio : affectedPortfolios) {
                    // Send real-time update to dashboard
                    PortfolioUpdate update = PortfolioUpdate.builder()
                        .portfolioId(portfolio.getId())
                        .type("PAYMENT_UPDATE")
                        .data(payPropEvent.getData())
                        .timestamp(Instant.now())
                        .build();
                    
                    webSocketService.sendToPortfolioSubscribers(portfolio.getId(), update);
                }
            }
        }
    }
}

Advanced Use Cases
Multi-Portfolio Management
javapublic class MultiPortfolioService {
    
    public CrossPortfolioAnalytics generateCrossPortfolioReport(List<Long> portfolioIds) {
        List<Portfolio> portfolios = portfolioRepository.findAllById(portfolioIds);
        
        // Aggregate data across portfolios
        CrossPortfolioAnalytics analytics = new CrossPortfolioAnalytics();
        
        for (Portfolio portfolio : portfolios) {
            PortfolioDashboard dashboard = portfolioAnalyticsService.buildComprehensiveDashboard(portfolio.getId());
            analytics.addPortfolioData(portfolio, dashboard);
        }
        
        // Calculate cross-portfolio insights
        analytics.calculatePerformanceComparisons();
        analytics.identifyTrends();
        analytics.generateRecommendations();
        
        return analytics;
    }
    
    public void syncTagsAcrossPortfolios(List<Long> portfolioIds, String tagName) {
        // Create tag in PayProp if it doesn't exist
        String payPropTagId = payPropClient.createOrGetTag(tagName);
        
        // Apply to all properties in selected portfolios
        for (Long portfolioId : portfolioIds) {
            List<Property> properties = propertyService.findByPortfolio(portfolioId);
            
            for (Property property : properties) {
                if (property.getPayPropId() != null) {
                    payPropClient.linkTagToProperty(payPropTagId, property.getPayPropId());
                }
            }
            
            // Update local tag mapping
            portfolioTagService.createPortfolioTag(portfolioId, tagName, payPropTagId);
        }
    }
}
Automated Portfolio Maintenance
java@Component
public class PortfolioMaintenanceAutomation {
    
    @Scheduled(cron = "0 0 9 * * MON") // Every Monday at 9 AM
    public void generateWeeklyPortfolioReports() {
        List<Portfolio> portfolios = portfolioService.findAllActive();
        
        for (Portfolio portfolio : portfolios) {
            try {
                // Generate comprehensive report
                PortfolioWeeklyReport report = generateWeeklyReport(portfolio);
                
                // Send to property owners and managers
                emailService.sendPortfolioWeeklyReport(portfolio, report);
                
                // Create reminders for urgent items
                createUrgentReminders(portfolio, report);
                
            } catch (Exception e) {
                log.error("Failed to generate weekly report for portfolio {}", portfolio.getId(), e);
            }
        }
    }
    
    @EventListener
    public void handleMaintenanceTicketCreated(MaintenanceTicketCreatedEvent event) {
        MaintenanceTicket ticket = event.getTicket();
        
        if (ticket.isEmergency()) {
            // Create emergency payment instruction if estimated cost available
            if (ticket.getEstimatedCost() != null) {
                createEmergencyMaintenancePayment(ticket);
            }
            
            // Notify portfolio managers immediately
            notificationService.sendEmergencyMaintenanceAlert(ticket);
        }
    }
    
    private void createEmergencyMaintenancePayment(MaintenanceTicket ticket) {
        // Create payment instruction linked to maintenance ticket
        PaymentDTO payment = PaymentDTO.builder()
            .propertyId(ticket.getProperty().getPayPropId())
            .beneficiaryType("global_beneficiary")
            .globalBeneficiary("Emergency Maintenance Fund")
            .amount(ticket.getEstimatedCost())
            .frequency("O") // One-time
            .categoryId(getMaintenanceCategoryId())
            .maintenanceTicketId(ticket.getPayPropTicketId())
            .reference("Emergency maintenance - " + ticket.getTitle())
            .description("Auto-created for emergency maintenance")
            .build();
            
        payPropClient.createPayment(payment);
    }
}

Testing Strategy
Integration Tests
java@SpringBootTest
@Testcontainers
public class PayPropIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
    
    @MockBean
    private PayPropClient payPropClient;
    
    @Test
    public void shouldSyncPropertyWithPortfolioTags() {
        // Given
        Portfolio portfolio = createTestPortfolio("Test Portfolio");
        Property property = createTestProperty(portfolio);
        
        when(payPropClient.createProperty(any()))
            .thenReturn(PayPropResponse.builder().id("payprop_prop_123").build());
        when(payPropClient.createOrGetTag("Test Portfolio"))
            .thenReturn("payprop_tag_456");
        
        // When
        String payPropId = portfolioSyncService.syncPropertyToPayProp(property.getId());
        
        // Then
        assertThat(payPropId).isEqualTo("payprop_prop_123");
        verify(payPropClient).linkTagToProperty("payprop_tag_456", "payprop_prop_123");
        
        Property updatedProperty = propertyRepository.findById(property.getId()).get();
        assertThat(updatedProperty.getPayPropId()).isEqualTo("payprop_prop_123");
        assertThat(updatedProperty.getSyncStatus()).isEqualTo(SyncStatus.SYNCED);
    }
    
    @Test
    public void shouldHandleMaintenanceWebhook() {
        // Given
        Property property = createSyncedTestProperty();
        PayPropWebhookEvent webhookEvent = createMaintenanceWebhookEvent(property.getPayPropId());
        
        // When
        webhookController.handleWebhook(webhookEvent, "valid_signature", "timestamp");
        
        // Then
        List<MaintenanceTicket> tickets = maintenanceRepository.findByPropertyId(property.getId());
        assertThat(tickets).hasSize(1);
        assertThat(tickets.get(0).getPayPropTicketId()).isEqualTo("payprop_ticket_789");
    }
}
PayProp Client Mock for Development
java@Profile("dev")
@Component
public class MockPayPropClient implements PayPropClient {
    
    private final Map<String, Object> mockData = new HashMap<>();
    private int idCounter = 1000;
    
    @Override
    public PayPropResponse createProperty(PropertyDTO property) {
        String mockId = "mock_prop_" + (idCounter++);
        mockData.put(mockId, property);
        
        return PayPropResponse.builder()
            .id(mockId)
            .status("success")
            .build();
    }
    
    @Override
    public List<MaintenanceTicket> getMaintenanceTickets(String propertyId, LocalDate from, LocalDate to) {
        // Return realistic mock data for development
        return Arrays.asList(
            MaintenanceTicket.builder()
                .id("mock_ticket_1")
                .propertyId(propertyId)
                .title("Leaking tap")
                .status("in_progress")
                .estimatedCost(BigDecimal.valueOf(150))
                .isEmergency(false)
                .createdDate(LocalDateTime.now().minusDays(3))
                .build(),
            MaintenanceTicket.builder()
                .id("mock_ticket_2")
                .propertyId(propertyId)
                .title("Heating system check")
                .status("resolved")
                .estimatedCost(BigDecimal.valueOf(300))
                .isEmergency(false)
                .createdDate(LocalDateTime.now().minusDays(7))
                .build()
        );
    }
}

Deployment & Configuration
Application Properties
yaml# PayProp Configuration
payprop:
  api:
    base-url: https://uk.payprop.com/api/agency/v1.1
    api-key: ${PAYPROP_API_KEY}
    rate-limit:
      requests-per-second: 5
      retry-attempts: 3
      retry-delay-ms: 1000
  webhook:
    secret-key: ${PAYPROP_WEBHOOK_SECRET}
    endpoint: ${APP_BASE_URL}/webhooks/payprop
    enabled: true
  sync:
    batch-size: 50
    enabled: true
    auto-sync-new-entities: true
    
# Portfolio Configuration  
portfolio:
  analytics:
    cache-duration: PT1H
    real-time-updates: true
  tags:
    auto-create-in-payprop: true
    sync-existing-tags: true
  maintenance:
    auto-create-payments: true
    emergency-notification: true
    
# Scheduling
scheduling:
  portfolio-reports:
    enabled: true
    cron: "0 0 9 * * MON"
  sync-status-check:
    enabled: true  
    cron: "0 */15 * * * *"  # Every 15 minutes
Monitoring & Alerting
java@Component
public class PayPropHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        try {
            // Test PayProp API connectivity
            payPropClient.getTokenMetaInformation();
            
            // Check sync status
            long failedSyncs = syncLogRepository.countByStatusAndCreatedAtAfter(
                SyncStatus.FAILED, 
                LocalDateTime.now().minusHours(1)
            );
            
            if (failedSyncs > 10) {
                return Health.down()
                    .withDetail("failed_syncs_last_hour", failedSyncs)
                    .build();
            }
            
            return Health.up()
                .withDetail("api_status", "connected")
                .withDetail("failed_syncs_last_hour", failedSyncs)
                .build();
                
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}

Migration Guide
Migrating from Lite Implementation
java@Component
public class PayPropMigrationService {
    
    @Transactional
    public void migrateToComprehensiveApi() {
        log.info("Starting PayProp API migration...");
        
        // 1. Migrate existing properties to use new fields
        migratePropertyData();
        
        // 2. Create portfolio tags in PayProp
        migratePortfolioTags();
        
        // 3. Set up webhooks
        configureWebhooks();
        
        // 4. Migrate financial data
        migrateFinancialData();
        
        // 5. Set up maintenance tracking
        initializeMaintenanceTracking();
        
        log.info("PayProp API migration completed successfully");
    }
    
    private void migratePropertyData() {
        List<Property> properties = propertyRepository.findAll();
        
        for (Property property : properties) {
            if (property.getPayPropId() != null) {
                // Update existing PayProp property with new fields
                PropertyDTO dto = PropertyDTO.builder()
                    .agentName(property.getPortfolio().getTeamName())
                    .responsibleAgentId(property.getPortfolio().getManagerPayPropId())
                    .customerReference(generateCustomerReference(property))
                    .build();
                    
                payPropClient.updateProperty(property.getPayPropId(), dto);
            }
        }
    }
    
    private void migratePortfolioTags() {
        List<Portfolio> portfolios = portfolioRepository.findAll();
        
        for (Portfolio portfolio : portfolios) {
            // Create tag in PayProp
            String tagName = portfolio.getName() + " Portfolio";
            String payPropTagId = payPropClient.createOrGetTag(tagName);
            
            // Link all portfolio properties to tag
            List<Property> properties = propertyService.findByPortfolio(portfolio.getId());
            for (Property property : properties) {
                if (property.getPayPropId() != null) {
                    payPropClient.linkTagToProperty(payPropTagId, property.getPayPropId());
                }
            }
            
            // Save tag mapping
            portfolioTagService.createPortfolioTag(portfolio.getId(), tagName, payPropTagId);
        }
    }
}
This comprehensive guide provides a complete reference for integrating with the full PayProp API, including all the advanced features missing from the lite version. The portfolio management, maintenance tracking, real-time webhooks, and comprehensive reporting capabilities will significantly enhance your property management platform's functionality.